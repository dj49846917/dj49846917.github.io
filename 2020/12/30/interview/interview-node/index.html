<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试——node篇 | 杜江的博客</title><meta name="description" content="Vue是一套用于构建用户界面的渐进式框架。"><meta name="keywords" content="面试,node"><meta name="author" content="杜江"><meta name="copyright" content="杜江"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/12/30/interview/interview-node/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="面试——node篇"><meta property="og:url" content="http://yoursite.com/2020/12/30/interview/interview-node/"><meta property="og:site_name" content="杜江的博客"><meta property="og:description" content="Vue是一套用于构建用户界面的渐进式框架。"><meta property="og:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=4104387483,4024841696&amp;fm=26&amp;gp=0.jpg"><meta property="article:published_time" content="2020-12-30T08:25:28.000Z"><meta property="article:modified_time" content="2024-04-18T03:43:57.888Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="vue3开发总结" href="http://yoursite.com/2021/01/04/vue3/vue3/"><link rel="next" title="面试——笔试篇" href="http://yoursite.com/2020/12/30/interview/interview-write/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/images/hexo/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">46</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">38</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">48</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#node模块化原理"><span class="toc-number">1.</span> <span class="toc-text">node模块化原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Node-异步单线程原理？（Nodejs如何实现高并发的）"><span class="toc-number">2.</span> <span class="toc-text">Node 异步单线程原理？（Nodejs如何实现高并发的）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nodejs与js有哪些不同？"><span class="toc-number">3.</span> <span class="toc-text">nodejs与js有哪些不同？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#谈谈你对Node的理解？优缺点？应用场景"><span class="toc-number">4.</span> <span class="toc-text">谈谈你对Node的理解？优缺点？应用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Node-如何多进程？"><span class="toc-number">5.</span> <span class="toc-text">Node 如何多进程？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node-js中进程通信"><span class="toc-number">6.</span> <span class="toc-text">node.js中进程通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#express实现原理"><span class="toc-number">7.</span> <span class="toc-text">express实现原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node的事件循环"><span class="toc-number">8.</span> <span class="toc-text">node的事件循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node的事件循环和浏览器的有什么区别吗？"><span class="toc-number">9.</span> <span class="toc-text">node的事件循环和浏览器的有什么区别吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#express-框架的核心特性"><span class="toc-number">10.</span> <span class="toc-text">express 框架的核心特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#express框架和Koa的区别"><span class="toc-number">11.</span> <span class="toc-text">express框架和Koa的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#koa-body原理"><span class="toc-number">12.</span> <span class="toc-text">koa-body原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node中的require加载文件的顺序"><span class="toc-number">13.</span> <span class="toc-text">node中的require加载文件的顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node模块分几类"><span class="toc-number">14.</span> <span class="toc-text">node模块分几类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内置模块、自定义模块、第三方模块"><span class="toc-number">14.1.</span> <span class="toc-text">内置模块、自定义模块、第三方模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node模块加载机制（node模块加载的原理）"><span class="toc-number">15.</span> <span class="toc-text">node模块加载机制（node模块加载的原理）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#请介绍你对Nodejs-异步I-O的理解"><span class="toc-number">16.</span> <span class="toc-text">请介绍你对Nodejs 异步I&#x2F;O的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#说一下你对-generator-的了解？"><span class="toc-number">17.</span> <span class="toc-text">说一下你对 generator 的了解？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#generator的原理"><span class="toc-number">18.</span> <span class="toc-text">generator的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node-如何捕捉错误，内存泄漏怎么排查；"><span class="toc-number">19.</span> <span class="toc-text">node 如何捕捉错误，内存泄漏怎么排查；</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node线程模型"><span class="toc-number">20.</span> <span class="toc-text">node线程模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#koa洋葱模型"><span class="toc-number">21.</span> <span class="toc-text">koa洋葱模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何封装中间件"><span class="toc-number">22.</span> <span class="toc-text">如何封装中间件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍一下你对中间件的理解"><span class="toc-number">23.</span> <span class="toc-text">介绍一下你对中间件的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使⽤过的koa2中间件"><span class="toc-number">24.</span> <span class="toc-text">使⽤过的koa2中间件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#负载均衡说一下"><span class="toc-number">25.</span> <span class="toc-text">负载均衡说一下</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如果要实现负载均衡，需要注意什么"><span class="toc-number">26.</span> <span class="toc-text">如果要实现负载均衡，需要注意什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程守护需要注意什么"><span class="toc-number">27.</span> <span class="toc-text">进程守护需要注意什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node开启多线程怎么做，PM2了解吗"><span class="toc-number">28.</span> <span class="toc-text">node开启多线程怎么做，PM2了解吗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nodejs能否充分利用多核处理器？"><span class="toc-number">29.</span> <span class="toc-text">Nodejs能否充分利用多核处理器？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pm2依据什么重启服务"><span class="toc-number">30.</span> <span class="toc-text">pm2依据什么重启服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pm2-原理"><span class="toc-number">31.</span> <span class="toc-text">pm2 原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pm2怎么做进程管理，进程挂掉怎么处理"><span class="toc-number">32.</span> <span class="toc-text">pm2怎么做进程管理，进程挂掉怎么处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不用pm2怎么做进程管理"><span class="toc-number">33.</span> <span class="toc-text">不用pm2怎么做进程管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍下node核心模块-主要是stream"><span class="toc-number">34.</span> <span class="toc-text">介绍下node核心模块(主要是stream)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是-IOC-机制，如何在-Node-里面使用"><span class="toc-number">35.</span> <span class="toc-text">什么是 IOC 机制，如何在 Node 里面使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NPM的作用是什么"><span class="toc-number">36.</span> <span class="toc-text">NPM的作用是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#node的包管理工具"><span class="toc-number">36.1.</span> <span class="toc-text">node的包管理工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#npm的简单指令"><span class="toc-number">37.</span> <span class="toc-text">npm的简单指令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#export和module-exports有什么区别？哪些代码会放在module-exports里？export有哪几种导出方式？加载时间不一样"><span class="toc-number">38.</span> <span class="toc-text">export和module.exports有什么区别？哪些代码会放在module.exports里？export有哪几种导出方式？加载时间不一样</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#export和export-default的区别"><span class="toc-number">39.</span> <span class="toc-text">export和export default的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node的-nextTick-和-vue的-nextTick-区别"><span class="toc-number">40.</span> <span class="toc-text">node的 nextTick 和 vue的 nextTick 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#process-nextTick和setImmediate有什么区别？"><span class="toc-number">41.</span> <span class="toc-text">process.nextTick和setImmediate有什么区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#V8垃圾回收机制"><span class="toc-number">42.</span> <span class="toc-text">V8垃圾回收机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是Nodejs，为什么要使用，有什么特点？"><span class="toc-number">43.</span> <span class="toc-text">什么是Nodejs，为什么要使用，有什么特点？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是错误优先的回调函数"><span class="toc-number">44.</span> <span class="toc-text">什么是错误优先的回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeJS-通常使用回调模式，如果在执行期间发生错误，会把错误作为回调的第一个参数传递到回调函数中"><span class="toc-number">44.1.</span> <span class="toc-text">NodeJS 通常使用回调模式，如果在执行期间发生错误，会把错误作为回调的第一个参数传递到回调函数中</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#说一下对端口的理解"><span class="toc-number">45.</span> <span class="toc-text">说一下对端口的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通过“IP地址-端口号”来区分不同的服务的"><span class="toc-number">45.1.</span> <span class="toc-text">通过“IP地址+端口号”来区分不同的服务的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是域名"><span class="toc-number">46.</span> <span class="toc-text">什么是域名</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#域名（英语：Domain-Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）"><span class="toc-number">46.1.</span> <span class="toc-text">域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#说一下对ip的理解"><span class="toc-number">47.</span> <span class="toc-text">说一下对ip的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IP是TCP-IP体系中的网络层协议-IP地址是用来识别网络上的设备，IP地址是由网络地址与主机地址两部分所组成"><span class="toc-number">47.1.</span> <span class="toc-text">IP是TCP&#x2F;IP体系中的网络层协议,IP地址是用来识别网络上的设备，IP地址是由网络地址与主机地址两部分所组成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Node原生api错误处理有了解吗？说一下"><span class="toc-number">48.</span> <span class="toc-text">Node原生api错误处理有了解吗？说一下</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍下Node-EventEmitter"><span class="toc-number">49.</span> <span class="toc-text">介绍下Node EventEmitter</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#eventEmitter做了什么？"><span class="toc-number">50.</span> <span class="toc-text">eventEmitter做了什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流是什么？"><span class="toc-number">51.</span> <span class="toc-text">流是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream流逝从源读取或写入数据并将其传输到连续流模板的管道。有4中类型：可读、可写、可读写、先写入，再读出来，每个流也是一个EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件"><span class="toc-number">51.1.</span> <span class="toc-text">  Stream流逝从源读取或写入数据并将其传输到连续流模板的管道。有4中类型：可读、可写、可读写、先写入，再读出来，每个流也是一个EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#readFile和createReadStream函数有什么区别？"><span class="toc-number">52.</span> <span class="toc-text">readFile和createReadStream函数有什么区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node如何进行跨域通信"><span class="toc-number">53.</span> <span class="toc-text">node如何进行跨域通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍下node文件查找优先级"><span class="toc-number">54.</span> <span class="toc-text">介绍下node文件查找优先级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node如何做错误监控-运行时与其他-。如何生成日志，日志等级"><span class="toc-number">55.</span> <span class="toc-text">node如何做错误监控(运行时与其他)。如何生成日志，日志等级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#是否了解glob，glob是如何处理文件的，业界是否还有其他解决方案"><span class="toc-number">56.</span> <span class="toc-text">是否了解glob，glob是如何处理文件的，业界是否还有其他解决方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何处理Node中未捕获的异常？"><span class="toc-number">57.</span> <span class="toc-text">如何处理Node中未捕获的异常？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Node如何做版本的升级？为什么要用nvm"><span class="toc-number">58.</span> <span class="toc-text">Node如何做版本的升级？为什么要用nvm?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图片上传到服务器的过程"><span class="toc-number">59.</span> <span class="toc-text">图片上传到服务器的过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mongodb与mysql的区别"><span class="toc-number">60.</span> <span class="toc-text">mongodb与mysql的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Node中的npm与版本管理"><span class="toc-number">61.</span> <span class="toc-text">Node中的npm与版本管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#token存在localstorage里，过期了怎么处理？"><span class="toc-number">62.</span> <span class="toc-text">token存在localstorage里，过期了怎么处理？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pnpm原理"><span class="toc-number">63.</span> <span class="toc-text">pnpm原理</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><header class="post-bg" id="page-header" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=4104387483,4024841696&amp;fm=26&amp;gp=0.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">杜江的博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">面试——node篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-12-30 16:25:28"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-12-30</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2024-04-18 11:43:57"><i class="fas fa-history fa-fw"></i> 更新于 2024-04-18</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fas fa-angle-right post-meta__separator"></i><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/node/">node</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="node模块化原理"><a href="#node模块化原理" class="headerlink" title="node模块化原理"></a>node模块化原理</h1><hr>
<h1 id="Node-异步单线程原理？（Nodejs如何实现高并发的）"><a href="#Node-异步单线程原理？（Nodejs如何实现高并发的）" class="headerlink" title="Node 异步单线程原理？（Nodejs如何实现高并发的）"></a>Node 异步单线程原理？（Nodejs如何实现高并发的）</h1><ol start="0">
<li>Node.js 实现异步的核心是事件，也就是说，它把每一个任务都当成 事件 来处理，然后通过 Event Loop 模拟了异步的效果</li>
<li>每个Node.js进程只有一个主线程在执行程序代码，形成一个执行栈（execution context stack)</li>
<li>主线程之外，还维护了一个”事件队列”（Event queue）。当用户的网络请求或者其它的异步操作到来时，node都会把它放到Event Queue之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。</li>
<li>主线程代码执行完毕完成后，然后通过Event Loop，也就是事件循环机制，开始到Event Queue的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从线程池中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交EventLoop处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。</li>
</ol>
<hr>
<h1 id="nodejs与js有哪些不同？"><a href="#nodejs与js有哪些不同？" class="headerlink" title="nodejs与js有哪些不同？"></a>nodejs与js有哪些不同？</h1><ol>
<li>js是编程语言，node是js的运行环境，node内置了一些增强js编程的功能模块。</li>
<li>js在浏览器客户端中运行，node在任何操作系统中都可以用</li>
<li>js可以在不同浏览器引擎上运行，node只能在v8引擎运行</li>
</ol>
<hr>
<h1 id="谈谈你对Node的理解？优缺点？应用场景"><a href="#谈谈你对Node的理解？优缺点？应用场景" class="headerlink" title="谈谈你对Node的理解？优缺点？应用场景"></a>谈谈你对Node的理解？优缺点？应用场景</h1><ul>
<li>nodejs是一个开源与跨平台的js运行环境，在浏览器外运行v8js引擎，利用事件驱动、非阻塞和异步输入输出模型等技术提高性能，就是一个服务器端的、非阻塞式I/O的、事件驱动的js运行环境</li>
<li>非阻塞异步：nodejs采用了非阻塞型的I/O机制，在做I/O操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作。</li>
<li>事件驱动就是当进来一个新的请求时，请求将会进入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数</li>
<li>优点：<ul>
<li>处理高并发场景性能更佳</li>
<li>适合I/O密集型应用，指的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做I/O硬盘内存存读写操作</li>
</ul>
</li>
<li>缺点：<ul>
<li>不适合CPU密集型应用，只支持单核CPU，不充分利用CPU，可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>
</ul>
</li>
<li>应用场景：<ul>
<li>用户表单手机系统、后台管理系统实时交互系统、考试系统、联网软件<br>高并发量的web程序</li>
<li>基于web、canvas等多人联网游戏</li>
<li>基于web的多人实时聊天客户端、聊天室、图文直播</li>
<li>单页面应用程序</li>
<li>操作数据库、为前端和移动端提供基于json的API</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Node-如何多进程？"><a href="#Node-如何多进程？" class="headerlink" title="Node 如何多进程？"></a>Node 如何多进程？</h1><ul>
<li>我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</li>
</ul>
<hr>
<h1 id="node-js中进程通信"><a href="#node-js中进程通信" class="headerlink" title="node.js中进程通信"></a>node.js中进程通信</h1><ul>
<li>使用子进程模块：可以使用 Node.js 的子进程模块（child_process）来创建子进程，并使用进程间通信机制（如进程间管道）来实现通信。</li>
<li>使用共享内存：Node.js 中的共享内存模块（sharedArrayBuffer）可以在多个进程间共享内存，从而实现进程间通信。</li>
<li>使用进程间消息传递：Node.js 提供了一个内置的进程间通信机制，可以使用 process.send() 方法在不同的进程之间发送消息。</li>
<li>使用进程间的 TCP 通信：可以使用 Node.js 的 net 模块建立 TCP 服务器和客户端，从而在不同的进程之间进行通信。</li>
</ul>
<hr>
<h1 id="express实现原理"><a href="#express实现原理" class="headerlink" title="express实现原理"></a>express实现原理</h1><ul>
<li><p>express的所有服务端逻辑处理都是通过中间件来实现的，中间件是一个函数，而app.use（）方法就是去装载这些函数,并放入一个数组中。</p>
</li>
<li><p>当前端一个请求传到服务器的时候，首先会经过request，然后是一系列的服务端处理，也就是中间件处理，存放于数组中的中间件采用后进先出的栈模式处理请求，最先入栈的中间件处理完请求之后，通过next将执行权交给第二个入栈的中间件，依次类推，直到数组末尾或者中间某个中间件没有调用next()函数，最后再将处理完的结果response回前端。</p>
</li>
</ul>
<hr>
<h1 id="node的事件循环"><a href="#node的事件循环" class="headerlink" title="node的事件循环"></a>node的事件循环</h1><ul>
<li>Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</li>
<li>当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环。</li>
</ul>
<hr>
<h1 id="node的事件循环和浏览器的有什么区别吗？"><a href="#node的事件循环和浏览器的有什么区别吗？" class="headerlink" title="node的事件循环和浏览器的有什么区别吗？"></a>node的事件循环和浏览器的有什么区别吗？</h1><ol>
<li>Node.js 的事件循环分为6个阶段</li>
<li>浏览器和Node 环境下，microtask 任务队列的执行时机不同</li>
<li>Node.js中，microtask 在事件循环的各个阶段之间执行</li>
<li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li>
<li>递归的调用process.nextTick()会导致I/O starving，官方推荐使用setImmediate()</li>
</ol>
<hr>
<h1 id="express-框架的核心特性"><a href="#express-框架的核心特性" class="headerlink" title="express 框架的核心特性"></a>express 框架的核心特性</h1><ol>
<li>可以设置中间件来响应 HTTP 请求。</li>
<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>
<li>可以通过向模板传递参数来动态渲染 HTML页面</li>
</ol>
<hr>
<h1 id="express框架和Koa的区别"><a href="#express框架和Koa的区别" class="headerlink" title="express框架和Koa的区别"></a>express框架和Koa的区别</h1><ul>
<li>编程模型不同：Express的中间件是线型的，Koa 的中间件是U型的（洋葱模型）</li>
<li>对语言特性的使用不同：express使用回调函数next()，koa v2.x 使用async/await 语法</li>
</ul>
<hr>
<h1 id="koa-body原理"><a href="#koa-body原理" class="headerlink" title="koa-body原理"></a>koa-body原理</h1><ul>
<li>koa-body中间件作用是将post等请求的请求体携带的数据解析到ctx.request.body中</li>
<li>原理：先用type-is这个包判断出请求的数据类型，然后根据不同类型用co-body(请求体解析)和formidable(数据类型是multipart，文件上传解析)来解析，拿到解析结果以后放到ctx.request.body或者ctx.request.files里面</li>
</ul>
<hr>
<h1 id="node中的require加载文件的顺序"><a href="#node中的require加载文件的顺序" class="headerlink" title="node中的require加载文件的顺序"></a>node中的require加载文件的顺序</h1><ol>
<li>如果some_module 是一个核心模块，直接加载，结束。</li>
<li>如果some_module以“ / ”、“ ./ ”或“ …/ ”开头，按路径加载 some_module，结束。</li>
<li>假设当前目录为 current_dir，按路径加载 current_dir/node_modules/some_module。<ul>
<li>如果加载成功，结束</li>
<li>如果加载失败，令current_dir为其父目录。</li>
<li>重复这一过程，直到遇到根目录，抛出异常，结束。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="node模块分几类"><a href="#node模块分几类" class="headerlink" title="node模块分几类"></a>node模块分几类</h1><h2 id="内置模块、自定义模块、第三方模块"><a href="#内置模块、自定义模块、第三方模块" class="headerlink" title="内置模块、自定义模块、第三方模块"></a>内置模块、自定义模块、第三方模块</h2><h1 id="node模块加载机制（node模块加载的原理）"><a href="#node模块加载机制（node模块加载的原理）" class="headerlink" title="node模块加载机制（node模块加载的原理）"></a>node模块加载机制（node模块加载的原理）</h1><ul>
<li><p>Node.js 中，模块加载过程分为 5 步：</p>
<ol>
<li>路径解析（Resolution）：根据模块标识找出对应模块（入口）文件的绝对路径</li>
<li>加载（Loading）：如果是 JSON 或 JS 文件，就把文件内容读入内存。如果是内置的原生模块，将其共享库动态链接到当前 Node.js 进程</li>
<li>包装（Wrapping）：将文件内容（JS 代码）包进一个函数，建立模块作用域，exports, require, module等作为参数注入</li>
<li>执行（Evaluation）：传入参数，执行包装得到的函数</li>
<li>缓存（Caching）：函数执行完毕后，将module缓存起来，并把module.exports作为require()的返回值返回</li>
</ol>
</li>
<li><p>路径解析的详细过程：（require加载文件的顺序）</p>
<ul>
<li>在加载模块时先去缓存中查找，如果为查找到再进行以下情况判断。<ol>
<li>模块有路径但没有扩展名<ul>
<li>按照require传入的path找到对应的路径，根据.js、.json、.node的顺序为path中的文件名加上后缀进行文件查找，如果找到则返回。</li>
<li>如果未找到，则会将path中的文件名视为目录名，找到其package.json文件，通过JSON.parse()解析出包描述对象，再取出main属性指定的文件名进行定位。如果文件缺少扩展名，将会进入扩展名分析的步骤。</li>
<li>如果该目录下没有package.json或者main属性指定的文件名错误，则会将index当做默认的文件名，然后依次查找index.js、index.json、index.node，如果找到则返回，如果未找到则require方法会抛出异常。</li>
</ul>
</li>
<li>模块有路径且有扩展名<ul>
<li>按照其path定位到对应的路径下，根据文件名查找对应的文件，如果找到则返回，如果未找到，require方法会抛出异常。</li>
</ul>
</li>
<li>模块没有路径且没有扩展名<ul>
<li>先去查找核心模块，有就返回</li>
<li>如果没有，去当前目录下的node_modules按照.js、.json、.node的顺序为模块名称加上扩展名然后去查找，如果找到则返回文件。</li>
<li>否则将模块名称视为目录名称，在node_modules/目录名下查找package.json文件，通过JSON.parse()解析出包描述对象，再取出main属性指定的文件名进行定位。</li>
<li>如果文件缺少扩展名，将会进入扩展名分析的步骤。如果该目录下没有package.json或者main属性指定的文件名错误，则会将index当做默认的文件名，然后依次查找index.js、index.json、index.node，如果找到则返回</li>
<li>如果未找到，去父目录中的node_modules中继续找，直到根目录。</li>
<li>如果到根目录还未找到文件，在全局目录查找，根据操作系统的环境变量中设置NODE_PATH变量</li>
</ul>
</li>
<li>模块没有路径且有扩展名<ul>
<li>去当前目录的node_modules下查找该文件名，如果有则返回</li>
<li>如果没有则去父目录中的node_modules下查找，直至到根目录，如果仍旧未找到，则会去全局目录下查找，依旧未找到则require方法会抛出异常。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="请介绍你对Nodejs-异步I-O的理解"><a href="#请介绍你对Nodejs-异步I-O的理解" class="headerlink" title="请介绍你对Nodejs 异步I/O的理解"></a>请介绍你对Nodejs 异步I/O的理解</h1><ul>
<li>node的异步I/O不等于非阻塞I/O。非阻塞I/O调用后会虽然也是立即返回，但是应用层会不断的重复I/O操作去轮询系统是否完成数据读取，让CPU处理状态判断，对CPU造成资源的浪费。然而在异步I/O里，基于多子线程的方式去解决了非阻塞I/O的问题，应用层(主线程)发起I/O请求后，就不再过问情况了。然后让子线程来完成数据获取，当读写完成后通知主线程。</li>
</ul>
<hr>
<h1 id="说一下你对-generator-的了解？"><a href="#说一下你对-generator-的了解？" class="headerlink" title="说一下你对 generator 的了解？"></a>说一下你对 generator 的了解？</h1><ol>
<li>概念：生成器是一种特殊的函数，它使用function*语法进行定义。在生成器函数内部，可以使用yield关键字来暂停函数的执行，并返回一个包含value和done属性的对象。value表示yield表达式的值，done表示函数是否已经执行完毕。</li>
<li>作用：生成器提供了一种更灵活、更可控的方式来处理异步编程。通过使用yield关键字，我们可以在函数执行过程中暂停和恢复，并且可以将异步操作以同步方式编写和理解。</li>
<li>原理：当我们调用生成器函数时，实际上并不会立即执行函数体内部的代码。而是返回一个迭代器对象，该迭代器对象实现了next()方法。每次调用next()方法时，生成器会从上一次暂停的位置继续执行代码，直到遇到下一个yield关键字或者函数结束。</li>
</ol>
<hr>
<h1 id="generator的原理"><a href="#generator的原理" class="headerlink" title="generator的原理"></a>generator的原理</h1><ul>
<li>当我们调用生成器函数时，实际上并不会立即执行函数体内部的代码。而是返回一个迭代器对象，该迭代器对象实现了next()方法。每次调用next()方法时，生成器会从上一次暂停的位置继续执行代码，直到遇到下一个yield关键字或者函数结束。</li>
</ul>
<hr>
<h1 id="node-如何捕捉错误，内存泄漏怎么排查；"><a href="#node-如何捕捉错误，内存泄漏怎么排查；" class="headerlink" title="node 如何捕捉错误，内存泄漏怎么排查；"></a>node 如何捕捉错误，内存泄漏怎么排查；</h1><ul>
<li>捕获：<ul>
<li>同步代码使用try catch</li>
<li>异步代码基本都提供了回调函数来处理错误</li>
<li>使用process模块，因为异常并不是事先准备好的，不能控制其到底在哪儿发生，所以我们可以通过监听应用进程的错误异常，从而捕获到不能预料的错误异常，保证应用不至于奔溃。</li>
</ul>
</li>
<li>排查：可以使用第三方工具memwatch、heapdump，可以分析到内存泄漏的位置。</li>
</ul>
<hr>
<h1 id="node线程模型"><a href="#node线程模型" class="headerlink" title="node线程模型"></a>node线程模型</h1><blockquote>
<p>node线程模型由于两部分组成：1个主线程，一个线程池。主线程内维护了一个事件循环，负责监听网络请求，建立连接、处理请求。如果请求不涉及IO操作，主线程处理请求，并把结果直接返回给客户端；如果请求涉及到IO操作，则把请求交给线程池处理，线程池处理完毕后通知主线程，主线程再把结果返回给客户端。</p>
</blockquote>
<hr>
<h1 id="koa洋葱模型"><a href="#koa洋葱模型" class="headerlink" title="koa洋葱模型"></a>koa洋葱模型</h1><ul>
<li>概念：Koa的洋葱模型是以next()函数为分割点，先由外到内执行Request的逻辑，然后再由内到外执行Response的逻辑，洋葱模型的核心原理主要是借助compose方法。</li>
<li>好处：<ul>
<li>更好地封装和复用代码逻辑，每个中间件只需要关注自己的功能。</li>
<li>更清晰的程序逻辑，通过中间件的嵌套可以表明代码的执行顺序。</li>
<li>更好的错误处理，每个中间件可以选择捕获错误或将错误传递给外层。</li>
<li>更高的扩展性，可以很容易地在中间件栈中添加或删除中间件。</li>
</ul>
</li>
<li>Koa的洋葱圈模型主要是通过Generator函数和Koa Context对象来实现的。</li>
<li>原理：通过compose函数来组合中间件，实现洋葱圈模型。compose接收一个中间件数组作为参数，执行数组中的中间件，返回一个可以执行所有中间件的函数。</li>
</ul>
<hr>
<h1 id="如何封装中间件"><a href="#如何封装中间件" class="headerlink" title="如何封装中间件"></a>如何封装中间件</h1><blockquote>
<p>在进入具体的业务处理之前，先让过滤器处理</p>
</blockquote>
<hr>
<h1 id="介绍一下你对中间件的理解"><a href="#介绍一下你对中间件的理解" class="headerlink" title="介绍一下你对中间件的理解"></a>介绍一下你对中间件的理解</h1><ul>
<li>中间件就是一个中间流程。目的是为了处理公共的逻辑、业务</li>
</ul>
<hr>
<h1 id="使⽤过的koa2中间件"><a href="#使⽤过的koa2中间件" class="headerlink" title="使⽤过的koa2中间件"></a>使⽤过的koa2中间件</h1><ul>
<li>koa-router: 提供了全面的路由功能</li>
<li>koa-bodyparser: 解析请求体的中间件</li>
<li>koa-views: 视图模板渲染中间件，支持ejs, nunjucks等众多模板引擎</li>
<li>koa-jwt: 使用JWT认证HTTP`请求。</li>
</ul>
<hr>
<h1 id="负载均衡说一下"><a href="#负载均衡说一下" class="headerlink" title="负载均衡说一下"></a>负载均衡说一下</h1><blockquote>
<p>当系统面临大量用户访问,负载过高的时候,通常会使用增加服务器数量来进行横向扩展,使用集群和负载均衡提高整个系统的处理能力</p>
</blockquote>
<hr>
<h1 id="如果要实现负载均衡，需要注意什么"><a href="#如果要实现负载均衡，需要注意什么" class="headerlink" title="如果要实现负载均衡，需要注意什么"></a>如果要实现负载均衡，需要注意什么</h1><ol>
<li>选取合适的负载均衡算法：不同的负载均衡算法适用于不同的应用场景，如轮询、最少连接、源IP散列等。选择合适的算法可以确保负载分配的公平性和效率。</li>
<li>考虑主机的性能：主机的性能是负载均衡的关键，必须确保主机能够承受所分配的负载。要定期监控主机的负载情况，并根据需要调整负载均衡策略。</li>
<li>考虑主机的可用性：负载均衡应该能够检测到主机的故障，并将流量重新分配到其他可用的主机上。使用心跳机制、健康检查等技术可以提高负载均衡的可用性。</li>
<li>考虑会话保持：如果应用程序需要保持会话状态，负载均衡器必须能够将同一用户的请求发送到同一台主机上，以确保会话的连续性。可以使用Cookie、URL重写等技术实现会话保持。</li>
<li>保障数据一致性：如果应用程序需要对数据进行写操作，负载均衡器必须能够确保数据的一致性。可以使用主从复制、数据同步等技术来解决数据一致性的问题。</li>
<li>考虑安全性：负载均衡器是系统的前端，必须能够保护系统免受网络攻击。可以使用防火墙、入侵检测等技术来提高系统的安全性。</li>
<li>考虑扩展性：负载均衡器应该能够根据系统的需要进行扩展。可以使用集群、分布式架构等技术来实现负载均衡的扩展。</li>
</ol>
<hr>
<h1 id="进程守护需要注意什么"><a href="#进程守护需要注意什么" class="headerlink" title="进程守护需要注意什么"></a>进程守护需要注意什么</h1><ul>
<li>事件延迟，因为 Node.js 主要是事件循环，如果主线程被长时间占用，就会导致事件执行有延迟，而最简单的办法就是使用 setTimeout 来判断。当我们设定 1000ms 执行某个事件，但是真正开始执行的时间大于 1000ms，那么我们就可能存在事件延迟了，而如果这个延迟越来越长，那么就必须进行告警提示开发者需要查看是否有异常事件被卡住，或者服务压力过大。</li>
<li>CPU 使用率，这是一个非常重要的指标，当发现 CPU 使用率长期维持在 70% 以上，我们就要考虑是否需要扩容，或者是增加进程的方式来解决这个问题，如果长期在 100% 那么肯定是需要扩容，或者检查内部代码逻辑是否存在问题。</li>
<li>内存变化，Node.js 的内存泄漏还是比较常见的，其最大的问题就是导致垃圾回收时间变长，从而影响 Node.js 的服务性能，最大的影响就是内存达到上限后进行重启，从而中断用户请求，引发在重启过程中的用户请求。</li>
<li>句柄变化，由于服务器的句柄是有上限的，如果无节制地开启句柄，将会导致系统性能损耗，从而影响进程的性能，因此我们必须在未使用句柄时进行释放，而如果长期不释放就会在达到上限时，导致新的请求无法开启新的句柄，从而无法正常提供服务。</li>
<li>进程异常重启次数，也是用来判断我们代码逻辑是否足够健壮的一个点，如果存在异常重启次数，那么一定是我们代码中存在未 catch 住的异常，或者说上面提到的内存泄漏上限问题。</li>
<li>以上指标在达到一定限度的时候，就应该进行告警提示开发者。</li>
</ul>
<hr>
<h1 id="node开启多线程怎么做，PM2了解吗"><a href="#node开启多线程怎么做，PM2了解吗" class="headerlink" title="node开启多线程怎么做，PM2了解吗"></a>node开启多线程怎么做，PM2了解吗</h1><ul>
<li>使用cluster模块。单个 Node.js 实例运行在单个线程中。 为了充分利用多核系统，有时需要启用一组 Node.js 进程去处理负载任务。cluster 模块可以创建共享服务器端口的子进程。</li>
<li>介绍: PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单<ul>
<li>主要特性：<ul>
<li>启动多子进程，充分使用cpu</li>
<li>子进程之间负载均衡</li>
<li>0秒重启</li>
<li>界面友好</li>
<li>提供进程交互接口</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Nodejs能否充分利用多核处理器？"><a href="#Nodejs能否充分利用多核处理器？" class="headerlink" title="Nodejs能否充分利用多核处理器？"></a>Nodejs能否充分利用多核处理器？</h1><ul>
<li>使用Cluster模块。它支持Nodejs应用程序开启多核，允许我们创建多个工作进程，这些进程可以在多个内核上并行运行，并共享一个端口来侦听事件。</li>
<li>每个进程使用IPC与主线程通信，并根据需要将服务器句传递给其他进程。主进程可以侦听端口本身并以循环方式将每个新连接传递给子进程，也可以将端口分配给子进程以便子进程侦听请求。</li>
</ul>
<hr>
<h1 id="pm2依据什么重启服务"><a href="#pm2依据什么重启服务" class="headerlink" title="pm2依据什么重启服务"></a>pm2依据什么重启服务</h1><blockquote>
<p>pm2采用心跳检测查看子进程是否出在活跃状态。每隔数秒向子进程发送心跳包，子进程如果不回复，那么调用kill杀死这个进程，然后再重新cluster.fork()一个新的进程，子进程可以监听错误事件，这时候可以发送消息给主进程，请求杀死自己，并且主进程此时重新调用cluster.fork一个新的子进程</p>
</blockquote>
<hr>
<h1 id="pm2-原理"><a href="#pm2-原理" class="headerlink" title="pm2 原理"></a>pm2 原理</h1><blockquote>
<p>PM2 的守护进程原理主要是将应用程序作为子进程启动，并在后台监控其运行情况。同时，PM2 本身也会被一个守护进程来监控和管理，以确保整个系统的稳定性和可靠性。<br>具体如下：</p>
</blockquote>
<ul>
<li>启动应用：当用户使用 PM2 启动应用时，PM2 会创建一个子进程，并将应用程序作为子进程来启动。同时，PM2 会记录该应用程序的相关信息，如 PID（进程 ID）、状态、日志等，并且会将这些信息保存到 PM2 的数据库中。</li>
<li>监控应用：一旦应用程序被启动，PM2 就会监控它的运行情况。如果应用程序意外退出或发生异常，PM2 将会自动重启应用程序。同时，PM2 会定期检查应用程序的资源占用情况，并且可以根据需要调整进程数、CPU 使用率等参数。</li>
<li>守护进程：为了确保 PM2 能够长时间稳定运行，PM2 本身也需要一个守护进程来监控其运行情况。该守护进程会定期检查 PM2 的健康状态，并且在 PM2 出现异常情况时进行相应的处理，例如重启进程、发送警告通知等。</li>
<li>日志管理：PM2 还提供了丰富的日志管理功能，可以将应用程序的日志导出到文件或远程服务器，并且支持实时查看、过滤等操作。这些日志信息对于排查问题、分析业务数据等都非常有用。</li>
</ul>
<hr>
<h1 id="pm2怎么做进程管理，进程挂掉怎么处理"><a href="#pm2怎么做进程管理，进程挂掉怎么处理" class="headerlink" title="pm2怎么做进程管理，进程挂掉怎么处理"></a>pm2怎么做进程管理，进程挂掉怎么处理</h1><hr>
<h1 id="不用pm2怎么做进程管理"><a href="#不用pm2怎么做进程管理" class="headerlink" title="不用pm2怎么做进程管理"></a>不用pm2怎么做进程管理</h1><hr>
<h1 id="介绍下node核心模块-主要是stream"><a href="#介绍下node核心模块-主要是stream" class="headerlink" title="介绍下node核心模块(主要是stream)"></a>介绍下node核心模块(主要是stream)</h1><hr>
<h1 id="什么是-IOC-机制，如何在-Node-里面使用"><a href="#什么是-IOC-机制，如何在-Node-里面使用" class="headerlink" title="什么是 IOC 机制，如何在 Node 里面使用"></a>什么是 IOC 机制，如何在 Node 里面使用</h1><hr>
<h1 id="NPM的作用是什么"><a href="#NPM的作用是什么" class="headerlink" title="NPM的作用是什么"></a>NPM的作用是什么</h1><h2 id="node的包管理工具"><a href="#node的包管理工具" class="headerlink" title="node的包管理工具"></a>node的包管理工具</h2><h1 id="npm的简单指令"><a href="#npm的简单指令" class="headerlink" title="npm的简单指令"></a>npm的简单指令</h1><hr>
<h1 id="export和module-exports有什么区别？哪些代码会放在module-exports里？export有哪几种导出方式？加载时间不一样"><a href="#export和module-exports有什么区别？哪些代码会放在module-exports里？export有哪几种导出方式？加载时间不一样" class="headerlink" title="export和module.exports有什么区别？哪些代码会放在module.exports里？export有哪几种导出方式？加载时间不一样"></a>export和module.exports有什么区别？哪些代码会放在module.exports里？export有哪几种导出方式？加载时间不一样</h1><ul>
<li>区别：<ul>
<li>exports返回的是模块函数，module.exports返回的是模块对象本身，返回的是一个类</li>
<li>exports的方法可以直接调用，module.exports需要new对象之后才可以调用</li>
</ul>
</li>
</ul>
<hr>
<h1 id="export和export-default的区别"><a href="#export和export-default的区别" class="headerlink" title="export和export default的区别"></a>export和export default的区别</h1><ol>
<li>export default只能导出一个变量，而export可以导出多个</li>
<li>export 导出的变量可以修改，export default则不行</li>
<li>语法差异，export const xxx = xxx是合法语句，但是export default则不可以</li>
</ol>
<hr>
<h1 id="node的-nextTick-和-vue的-nextTick-区别"><a href="#node的-nextTick-和-vue的-nextTick-区别" class="headerlink" title="node的 nextTick 和 vue的 nextTick 区别"></a>node的 nextTick 和 vue的 nextTick 区别</h1><hr>
<h1 id="process-nextTick和setImmediate有什么区别？"><a href="#process-nextTick和setImmediate有什么区别？" class="headerlink" title="process.nextTick和setImmediate有什么区别？"></a>process.nextTick和setImmediate有什么区别？</h1><ul>
<li>传递给setImmediate函数的回调将在事件队列上的下一次迭代中执行。</li>
<li>另一方面，回调传递给process.nextTick，在下一次迭代之前以及程序中当前运行的操作完成之后执行。咋应用程序启动时，开始遍历事件队列之前调用他的回调。</li>
<li>因此，回调process.nextTick总是在setImmediate之前调用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码：</span><br><span class="line"></span><br><span class="line">setImmediate(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&quot;first&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&quot;second&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&quot;third&quot;);</span><br><span class="line"></span><br><span class="line">将按顺序输出：</span><br><span class="line">third</span><br><span class="line">second</span><br><span class="line">first</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="V8垃圾回收机制"><a href="#V8垃圾回收机制" class="headerlink" title="V8垃圾回收机制"></a>V8垃圾回收机制</h1><hr>
<h1 id="什么是Nodejs，为什么要使用，有什么特点？"><a href="#什么是Nodejs，为什么要使用，有什么特点？" class="headerlink" title="什么是Nodejs，为什么要使用，有什么特点？"></a>什么是Nodejs，为什么要使用，有什么特点？</h1><ul>
<li>概念：Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用</li>
<li>作为web前端开发人员需要了解一门后台语言，对于前端开发人员nodejs 更容易上手</li>
<li>特点：<ol>
<li>RESTful API</li>
<li>单线程</li>
<li>非阻塞IO</li>
<li>V8虚拟机</li>
<li>事件驱动</li>
</ol>
</li>
</ul>
<hr>
<h1 id="什么是错误优先的回调函数"><a href="#什么是错误优先的回调函数" class="headerlink" title="什么是错误优先的回调函数"></a>什么是错误优先的回调函数</h1><h2 id="NodeJS-通常使用回调模式，如果在执行期间发生错误，会把错误作为回调的第一个参数传递到回调函数中"><a href="#NodeJS-通常使用回调模式，如果在执行期间发生错误，会把错误作为回调的第一个参数传递到回调函数中" class="headerlink" title="NodeJS 通常使用回调模式，如果在执行期间发生错误，会把错误作为回调的第一个参数传递到回调函数中"></a>NodeJS 通常使用回调模式，如果在执行期间发生错误，会把错误作为回调的第一个参数传递到回调函数中</h2><h1 id="说一下对端口的理解"><a href="#说一下对端口的理解" class="headerlink" title="说一下对端口的理解"></a>说一下对端口的理解</h1><h2 id="通过“IP地址-端口号”来区分不同的服务的"><a href="#通过“IP地址-端口号”来区分不同的服务的" class="headerlink" title="通过“IP地址+端口号”来区分不同的服务的"></a>通过“IP地址+端口号”来区分不同的服务的</h2><h1 id="什么是域名"><a href="#什么是域名" class="headerlink" title="什么是域名"></a>什么是域名</h1><h2 id="域名（英语：Domain-Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）"><a href="#域名（英语：Domain-Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）" class="headerlink" title="域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）"></a>域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）</h2><h1 id="说一下对ip的理解"><a href="#说一下对ip的理解" class="headerlink" title="说一下对ip的理解"></a>说一下对ip的理解</h1><h2 id="IP是TCP-IP体系中的网络层协议-IP地址是用来识别网络上的设备，IP地址是由网络地址与主机地址两部分所组成"><a href="#IP是TCP-IP体系中的网络层协议-IP地址是用来识别网络上的设备，IP地址是由网络地址与主机地址两部分所组成" class="headerlink" title="IP是TCP/IP体系中的网络层协议,IP地址是用来识别网络上的设备，IP地址是由网络地址与主机地址两部分所组成"></a>IP是TCP/IP体系中的网络层协议,IP地址是用来识别网络上的设备，IP地址是由网络地址与主机地址两部分所组成</h2><h1 id="Node原生api错误处理有了解吗？说一下"><a href="#Node原生api错误处理有了解吗？说一下" class="headerlink" title="Node原生api错误处理有了解吗？说一下"></a>Node原生api错误处理有了解吗？说一下</h1><hr>
<h1 id="介绍下Node-EventEmitter"><a href="#介绍下Node-EventEmitter" class="headerlink" title="介绍下Node EventEmitter"></a>介绍下Node EventEmitter</h1><hr>
<h1 id="eventEmitter做了什么？"><a href="#eventEmitter做了什么？" class="headerlink" title="eventEmitter做了什么？"></a>eventEmitter做了什么？</h1><ul>
<li>nodejs中任何对象发出的事件，都是eventEmitter类的实例，就像http模块所有eventEmitter类都可以使用eventEmitter.on这个函数将事件监听附加到事件上，然后一旦捕捉到这样的事件，就会同步的逐个调用它的监听器，并安排合适执行其关联的回调函数</li>
</ul>
<hr>
<h1 id="流是什么？"><a href="#流是什么？" class="headerlink" title="流是什么？"></a>流是什么？</h1><h2 id="Stream流逝从源读取或写入数据并将其传输到连续流模板的管道。有4中类型：可读、可写、可读写、先写入，再读出来，每个流也是一个EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件"><a href="#Stream流逝从源读取或写入数据并将其传输到连续流模板的管道。有4中类型：可读、可写、可读写、先写入，再读出来，每个流也是一个EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件" class="headerlink" title="  Stream流逝从源读取或写入数据并将其传输到连续流模板的管道。有4中类型：可读、可写、可读写、先写入，再读出来，每个流也是一个EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件"></a>  Stream流逝从源读取或写入数据并将其传输到连续流模板的管道。有4中类型：可读、可写、可读写、先写入，再读出来，每个流也是一个EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件</h2><h1 id="readFile和createReadStream函数有什么区别？"><a href="#readFile和createReadStream函数有什么区别？" class="headerlink" title="readFile和createReadStream函数有什么区别？"></a>readFile和createReadStream函数有什么区别？</h1><ul>
<li>readFile函数异步读取文件的全部内容，并存储在内存中，然后再传递给用户</li>
<li>createReadStream使用一个可读的流，逐块读取文件，而不是全部存储在内存中。</li>
<li>与readFile相比，createReadStram使用更少的内存和更快的速度来优化文件读取操作。如果文件相当大，用户不必等待很长时间直到读取整个内容，因为读取时会现象用户发送小块内容</li>
</ul>
<hr>
<h1 id="node如何进行跨域通信"><a href="#node如何进行跨域通信" class="headerlink" title="node如何进行跨域通信"></a>node如何进行跨域通信</h1><ol>
<li>使用socket.io</li>
<li>使用cors，设置node服务器，配置Access-control-allow-origin</li>
</ol>
<hr>
<h1 id="介绍下node文件查找优先级"><a href="#介绍下node文件查找优先级" class="headerlink" title="介绍下node文件查找优先级"></a>介绍下node文件查找优先级</h1><hr>
<h1 id="node如何做错误监控-运行时与其他-。如何生成日志，日志等级"><a href="#node如何做错误监控-运行时与其他-。如何生成日志，日志等级" class="headerlink" title="node如何做错误监控(运行时与其他)。如何生成日志，日志等级"></a>node如何做错误监控(运行时与其他)。如何生成日志，日志等级</h1><ul>
<li><p>如何监控</p>
<ol>
<li>错误类型<ul>
<li>当出现语法错误或运行时错误时，会触发js错误</li>
<li>当试图访问一个不存在或没有访问的文件时，会触发系统错误</li>
<li>除了系统错误和js错误外，用户还可以自定义错误</li>
</ul>
</li>
<li>监控异常日志<ul>
<li>异常日志同城用来记录那些意外发生的异常错误。通过日志的记录，可以根据异常信息，去定位bug穿的具体位置，以快速修复问题</li>
</ul>
</li>
</ol>
</li>
<li><p>如何生成日志</p>
<ul>
<li>使用日志中间件，日志中间件可以将关键数据按一定格式输出到日志文件中。如:<ul>
<li>log4j</li>
<li>connect</li>
</ul>
</li>
</ul>
</li>
<li><p>日志等级</p>
<ul>
<li>console.log: 普通日志</li>
<li>console.info: 普通信息</li>
<li>console.warn: 警告信息</li>
<li>console.error: 错误信息</li>
</ul>
</li>
</ul>
<hr>
<h1 id="是否了解glob，glob是如何处理文件的，业界是否还有其他解决方案"><a href="#是否了解glob，glob是如何处理文件的，业界是否还有其他解决方案" class="headerlink" title="是否了解glob，glob是如何处理文件的，业界是否还有其他解决方案"></a>是否了解glob，glob是如何处理文件的，业界是否还有其他解决方案</h1><hr>
<h1 id="如何处理Node中未捕获的异常？"><a href="#如何处理Node中未捕获的异常？" class="headerlink" title="如何处理Node中未捕获的异常？"></a>如何处理Node中未捕获的异常？</h1><blockquote>
<p>可以在进程级别捕获应用程序中未捕获的异常。为此将侦听器附加到process全局对象</p>
</blockquote>
<hr>
<h1 id="Node如何做版本的升级？为什么要用nvm"><a href="#Node如何做版本的升级？为什么要用nvm" class="headerlink" title="Node如何做版本的升级？为什么要用nvm?"></a>Node如何做版本的升级？为什么要用nvm?</h1><ul>
<li>提升webpack打包的速度，因为webpack可能会用到新的Api来提升打包速度</li>
<li>因为它可以切换Node版本</li>
</ul>
<hr>
<h1 id="图片上传到服务器的过程"><a href="#图片上传到服务器的过程" class="headerlink" title="图片上传到服务器的过程"></a>图片上传到服务器的过程</h1><blockquote>
<p>type等于file的input框，有个onChange事件，一旦file发生了变化，在高版本的浏览器里，js里有一个FileReader的类，可以调用FileReader.readAsDataURL的方法，去读取到文件的base64的字符串，拿到这个字符串之后，就可以用image标签塞到src里面去，这样就完成了预览功能，当你点击保存的时候，把这个file通过form表单的形式提交给后端，后端传到服务器上去<br>全版本：当触发onchange事件时，通过form表单提交给后端，后端返回给你一个图片url，拿到后放到url里</p>
</blockquote>
<hr>
<h1 id="mongodb与mysql的区别"><a href="#mongodb与mysql的区别" class="headerlink" title="mongodb与mysql的区别"></a>mongodb与mysql的区别</h1><hr>
<h1 id="Node中的npm与版本管理"><a href="#Node中的npm与版本管理" class="headerlink" title="Node中的npm与版本管理"></a>Node中的npm与版本管理</h1><hr>
<h1 id="token存在localstorage里，过期了怎么处理？"><a href="#token存在localstorage里，过期了怎么处理？" class="headerlink" title="token存在localstorage里，过期了怎么处理？"></a>token存在localstorage里，过期了怎么处理？</h1><ul>
<li>token一般放到cookie里，后端可以写入cookie,所以让后端去处理，如果后端不处理，当token失效后，前端就跳转到登录页面即可</li>
</ul>
<hr>
<h1 id="pnpm原理"><a href="#pnpm原理" class="headerlink" title="pnpm原理"></a>pnpm原理</h1><hr>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">杜江</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/12/30/interview/interview-node/">http://yoursite.com/2020/12/30/interview/interview-node/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">杜江的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/node/">node</a></div><div class="post_share"><div class="social-share" data-image="/images/hexo/hexo_logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/04/vue3/vue3/"><img class="prev-cover" data-src="/images/vue/vue.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">vue3开发总结</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/30/interview/interview-write/"><img class="next-cover" data-src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=955487690,3458128037&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试——笔试篇</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/12/29/interview/interview-css/" title="面试——css篇"><img class="relatedPosts_cover" data-src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2908530132,3956932538&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-29</div><div class="relatedPosts_title">面试——css篇</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/28/interview/interview-html/" title="面试——html篇"><img class="relatedPosts_cover" data-src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2908530132,3956932538&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-28</div><div class="relatedPosts_title">面试——html篇</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/29/interview/interview-typescript/" title="面试——typescript篇"><img class="relatedPosts_cover" data-src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3746182100,898429560&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-29</div><div class="relatedPosts_title">面试——typescript篇</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/30/interview/interview-write/" title="面试——笔试篇"><img class="relatedPosts_cover" data-src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=955487690,3458128037&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-30</div><div class="relatedPosts_title">面试——笔试篇</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/29/interview/interview-webpack/" title="面试——webpack篇"><img class="relatedPosts_cover" data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3813469802,1665117316&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-29</div><div class="relatedPosts_title">面试——webpack篇</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/29/interview/interview-other/" title="面试——其他篇"><img class="relatedPosts_cover" data-src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=955487690,3458128037&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-29</div><div class="relatedPosts_title">面试——其他篇</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC81MDYyNy8yNzExMA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 杜江</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://dj49846917.github.io/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/third-party/click_heart.js"></script></body></html>